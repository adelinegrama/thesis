\documentclass[a4paper,12pt]{report}
\usepackage{config}

% Description
\newcommand{\authorName}{GRAMA Alina}
\newcommand{\authorNameRu}{ГРАМА Алина}
\newcommand{\thesisTitleRu}{Разработка web API на C\#}
\newcommand{\thesisTitle}{Dezvoltarea unui web API în C\#}
\newcommand{\uniGroupName}{DJ2203}
\newcommand{\thesisType}{licență}
\newcommand{\programulDeStudii}{licență}
\newcommand{\programulDeStudiiRu}{Дипломная работа}
\newcommand{\identificatorulCursului}{0211.7 Designul jocurilor}
\newcommand{\identificatorulCursuluiRu}{0211.7 Гейм дизайн}

\renewcommand{\year}{2025}
\newcommand{\location}{Chișinău}
\newcommand{\locationRu}{Кишинев}
\newcommand{\conferencesList}{Conferința Studențească, Editia XXVIII-a, \year}
\newcommand{\conducatorNume}{Curmanschii}
\newcommand{\conducatorPrenume}{Anton}
\newcommand{\conducatorNumeRu}{Курманский}
\newcommand{\conducatorPrenumeRu}{Антон}
\newcommand{\githubthesis}{\url{https://github.com/adelinegrama/thesis.git}}
\newcommand{\githubwebAPI}{\url{https://github.com/adelinegrama/webAPI.git}}
\newcommand{\chapterCount}{3}

\begin{document}

\input{foaie_de_titlu}

\clearpage
\tableofcontents

\clearpage
\unnumberedChapter{Список аббревиатур}
\begin{acronym}[JPEG]
    \acro{API}{Application Programming Interface}
    \acro{REST}{Representational State Transfer}
    \acro{DI}{Dependency Injection}
    \acro{ООП}{Объектно-Ориентированное Программирование}
    \acro{EF}{Entity Framework}
    \acro{HTTP}{HyperText Transfer Protocol}
    \acro{CRUD}{Create Read Update Delete}
    \acro{СУБД}{Система Управления Базами Данных}
    \acro{URL}{Uniform Resource Locator}
    \acro{MVC}{Model View Controller}
    \acro{SQL}{Structured Query Language}
    \acro{ORM}{Object-Relational Mapping}
    \acro{DTO}{Data Transfer Object}
    \acro{}{}
\end{acronym}


% I think this one's required to be capitalized.
\unnumberedChapter{ВВЕДЕНИЕ}

\markpage{usefulStuffBegin}

\textbf{Актуальность и важность темы.}

Механизм веб-\acs{API} широко используется для различных приложений, таких как веб-приложения, мобильные приложения, 
облачные сервисы и интеграция с внешними системами. Данный \acs{API} позволяет клиенту и серверу взаимодействовать друг с другом, 
обеспечивая надежный обмен данными. Использование ASP.NET Core предоставляет средства для разработки \acs{REST}ful \acs{API}, 
который является стандартом в установлении взаимодействия между клиентом и сервером.

Исходя из этого, изучение веб-\acs{API} является нужным для работы с базами данных для создания современных приложений.

\textbf{Цель и задачи.}

Целью дианной работы является демонстрация возможностей ASP.NET Core как современного фреймворка для разработки веб-\acs{API}. 
В рамках исследования и практической реализации будут продемонстрированы основные преимущества ASP.NET Core, включая его 
высокую производительность, модульность и гибкость в создании \acs{REST}ful \acs{API}. Для этого было решено создать приложение для 
продажи товаров, которое представит возможности веб-\acs{API} созданные на языке C\#.

\textbf{Методологическое и технологическое обеспечение.}

Разработка веб-\acs{API} включает использование принципов \acs{ООП} для структурирования кода, повышения его гибкости и читаемости. 
Основой создания приложения является \ac{REST}, обеспечивающий стандартизированный подход к построению \acs{API} через использование 
\acs{HTTP}-методов, статусных кодов и \acs{URL}-адресов. Для документирования и упрощения тестирования применяется Swagger, что позволяет 
визуализировать и описывать \acs{API}. Языком программирования является C\#, в качестве фреймворка используется ASP.NET Core.

\textbf{Научная новизна/оригинальность темы.}

Разработка веб-\acs{API} на C\# является актуальной областью исследований, поскольку современные веб-приложения требуют гибких, 
масштабируемых и безопасных способов взаимодействия между клиентами и серверами. В рамках данной работы изучаются
и применяются современные подходы к созданию веб-\acs{API}, такие как использование архитектурного стиля \acs{REST}, внедрение паттернов 
проектирования, а также применение различных подходов к проектированию базы данных.

\textbf{Прикладная значимость.}

Разработка веб-сервисов является неотъемлемой частью многих современных IT-проектов, и знание принципов построения высокоэффективных 
\acs{API} открывает широкие возможности для работы в таких областях, как разработка веб-приложений, мобильных приложений, 
а также в сфере интеграции различных сервисов и систем.

Основная цель работы состоит в получении практических знаний и умений, которые будут востребованы в будущей профессиональной деятельности. 
Создание функционального веб-\acs{API} на C\# является не только учебной задачей, но и полезным продуктом, который можно применить в реальных проектах, 
что делает его ценным опытом для работы в разработке веб-\acs{API} приложений.

\textbf{Краткое описание глав.}

В первой главе была описана базовая теория, касающаяся разработки веб-\acs{API} приложения. 
Были рассмотрены такие понятия как \acs{ORM}, \acs{EF} Core и \acs{DI}, а также назначение веб-\acs{API}. 
Данная теория служит базой для проектирования и последующей реализации веб-\acs{API}.

Во второй главе рассмотрено проектирование архитектуры системы приложения. 
Были определены подходы к построению архитектуры системы, подходы к проектированию структуры базы данных. 
Проанализированы виды ключей в базах данных, а также, виды связей между сущностями. 
Все это является необходимым для последующей реализации системы.

В третьей главе описана постепенная реализация системы. Рассмотрена реализация \acs{DTO}, валидация данных, 
миграции, unit-тестирование, а также, были изучены более подробно контроллеры. 
Данная глава, также, предоставляет фрагменты кода приложения.

\chapter{Теоретические основы веб-\acs{API} и ASP.NET Core}\label{intro_chapter_title}

\section{Мотивация создания приложения}

Мотивацией написания данного приложения является не только образовательная цель, но также, идея для собственного проекта, который
имеет потенциал для реального применения. Масштаб и сложность данного проекта вызывают сомнения относительно возможности завершения проекта в сроки 
дипломной работы. Такой проект требует более объемной работы, возможно, участия команды, что в рамках текущих условий и сроков может оказаться 
сложным для самостоятельной реализации. Поэтому, было решено сделать более простой проект, который принесет значительный вклад в развитие знаний и навыков 
в области веб-разработки.

\section{Понятие и назначение веб-\acs{API}}

\subsection{Введение}

Веб-\acs{API}, который означает “интерфейс прикладного программирования” для клиента и сервера, 
является набором правил и протоколов, позволяющий различным приложениям понимать и взаимодействовать 
друг с другом. Они предоставляют возможность веб-приложениям общаться друг с другом с помощью баз данных, 
обеспечивая своевременную передачу данных. веб-\acs{API} работают на основе модели запрос-ответ, где клиент 
отправляет \acs{HTTP}-запрос  на сервер, а сервер обрабатывает запрос и отправляет ответ клиенту.

\subsection{Определение веб-\acs{API} и их виды}

Фреймворк ASP.NET Core поддерживает два подхода для создания веб-\acs{API}: \acs{API}, основанные на контроллерах 
и минимальные \acs{API}. Контроллеры -- классы, производные от класса \texttt{ControllerBase}, которые определяют методы 
для каждого \acs{HTTP} метода, а минимальные \acs{API} основываются на создании \acs{API} с минимальным количеством 
зависимостей и использовании методов \texttt{app.MapGet}, \texttt{app.MapPost}, \texttt{app.MapPut} и \texttt{app.MapDelete}.\cite{controller_vs_minimal_api}

\subsection{Основные архитектурные стили веб-\acs{API}: \acs{REST}}

\ac{REST} -- архитектурный стиль для создания систем, которые описывают принципы 
взаимодействия между клиентом и сервером. Основная цель \acs{REST} -- создать простые и масштабируемые веб-сервисы. 
Данный архитектурный стиль используется для взаимодействия между клиентом и сервером через стандартные \acs{HTTP}-запросы.

Основные принципы \acs{REST}:
\begin{itemize}
    \item
        \textbf{Клиент-сервер}: клиент отвечает за взаимодействие с пользователем, сервер - за обработку запросов и управление данными.
    \item 
        \textbf{Отсутствие состояния (Stateless)}: каждый запрос клиента к серверу должен содержать всю информацию, необходимую для его обработки, 
        сервер не должен хранить состояние между запросами.
    \item
        \textbf{Кэшируемость (Cacheable)}: кэширование способствует предотвращению повторных запросов на сервер.
    \item
        \textbf{Единообразие интерфейса (Uniform Interface)}: все взаимодействия с API осуществляются с помощью единого стандартизированного интерфейса.
    \item
        \textbf{Код по запросу (Code on Demand)}: позволяет серверу расширять или настраивать функциональность клиента путем передачи исполняемого кода.
\end{itemize}

В \acs{REST}ful \acs{API} есть 4 \acs{HTTP}-метода, которые, также, являются операциями \acs{CRUD}: GET, POST, PUT, DELETE.

\section{ASP.NET Core как платформа для разработки веб-\acs{API}}

\subsection{История и эволюция}
ASP.NET Core -- это кроссплатформенный, высокопроизводительный и модульный фреймворк для разработки веб-приложений и \acs{API}, созданный Microsoft. 
Он является преемником ASP.NET и представляет собой трансформацию архитектуры веб-разработки на платформе .NET.

В 2016 году Microsoft представила ASP.NET Core 1.0 - полностью переработанную версию ASP.NET, созданную для работы на Windows, Linux и macOS.\cite{announcing_asp_net_core_1_0}

В 2017 году вышел ASP.NET Core 2.0, который упростил разработку и добавил улучшенную работу с Entity Framework Core.\cite{announcing_asp_net_core_2_0}

В 2019 году Microsoft выпустила ASP.NET Core 3.0, который отказался от поддержки .NET Framework, полностью перейдя на .NET Core, 
а также, улучшилась работа с веб-\acs{API}, появилась возможность создавать веб-\acs{API} без необходимости в \acs{MVC}.\cite{announcing_asp_net_core_3_0}

В 2020-2021 - объединение .NET Framework и .NET Core в единую платформу .NET 5, а также были представлены минимальные \acs{API} в .NET 6.\cite{announcing_dot_net_5_0}\cite{announcing_dot_net_6_0}

В 2022 в .NET 7 появилась улучшенная работа с веб-\acs{API} и минимальными \acs{API}.\cite{announcing_dot_net_7_0}

В 2023-2024 в .NET 8-9 - улучшения фреймворка.\cite{announcing_dot_net_8_0}\cite{announcing_dot_net_9_0}

\subsection{Основные преимущества}

ASP.NET Core сочетает в себе производительность, гибкость и современный подход к веб-разработке, что делает его отличным выбором 
для создания масштабируемых и надежных веб-приложений.

Преимущества выбора ASP.NET Core:
\begin{itemize}
    \item
        \textbf{Кроссплатформенность} -- работает на Windows, Linux и macOS, что позволяет разрабатывать и развертывать приложения на разных операционных системах.
    \item 
        \textbf{Модульность и гибкость} -- поддерживает как контроллеры (\acs{MVC},), так и минимальные \acs{API}, а также Razor Pages, Blazor, что позволяет выбрать 
        подходящую архитектуру для проекта.
    \item
        \textbf{Встроенный механизм зависимостей} -- \acs{DI} позволяет легко управлять зависимостями и создавать тестируемые, расширяемые приложения.
    \item
        \textbf{Современные технологии веб-разработки} -- интеграция с \acs{EF} Core для работы с базами данных.
    \item
        \textbf{Большая поддержка сообщества и официальная документация от Microsoft} -- регулярные обновления, обширная документация и большое сообщество 
        разработчиков делают ASP.NET Core надежным и актуальным фреймворком.
\end{itemize}

Данная технология была выбрана, так как она является по факту стандартом в написании веб-\acs{API} приложений.

\section{Object-Relational Mapping и Entity Framework Core}

\subsection{Определение \acs{ORM} и \acs{EF} Core}

\acs{ORM} -- технология, которая позволяет работать с базами данных с использованием \acs{ООП} вместо написания \acs{SQL}-запросов. 
Данная технология является посредником между языком программирования и базой данных. 
При ее помощи можно получать данные из базы данных и работать с ними как с объектами, 
а также, записывать объекты из программы в базу данных.\cite{orm}

Преимущества \acs{ORM}:
\begin{itemize}
    \item
        Выполнение \acs{CRUD} операций без использования \acs{SQL} вручную.
    \item
        Представление данных из базы данных как объектов, с которыми может работать язык программирования.
    \item
        Безошибочное сопоставление полей из базы данных и свойств полученных объектов друг с другом.
\end{itemize}

\textbf{Entity Framework Core} -- \acs{ORM} фреймворк, который позволяет сопоставлять C\# классы с таблицами базы данных, 
то есть данная технология позволяет взаимодействовать с базой данных через C\# код, а не напрямую через \acs{SQL}-запросы.\cite{ef_core}


\subsection{Класс \texttt{DbContext}}

\acs{EF} Core использует класс \texttt{DbContext}, который является неотъемлемой частью \acs{EF}, позволяющий запрашивать и сохранять данные. 

\texttt{DbContext} предоставляет следующие возможности:
\begin{itemize}
    \item
        Управление подключением к базе данных через строку подключения.
    \item 
        Написание и выполнение запросов.
    \item
        Сохранение и отслеживание изменений данных в базе данных.
\end{itemize}

\subsection{Основные преимущества \acs{EF} Core}

\begin{enumerate}
    \item
        \acs{EF} Core предлагает встроенную систему миграций, которая позволяет легко 
        обновлять базу данных, добавлять новые таблицы, обновлять схемы.
    \item
        \acs{EF} Core поддерживает сортировку и фильтрацию данных, 
        что является необходимым при работе с большими объемами информации, эти функции позволяют оптимизировать производительность 
        запросов и делать их более быстрыми и эффективными.
    \item
        Вместо написания \acs{SQL}-запросов можно работать с объектами и классами, 
        что делает код более понятным и удобным в поддержке.
    \item
        \acs{EF} Core поддерживает широкий спектр баз данных.
\end{enumerate}

\section{Dependency Injection в ASP.NET Core}

\subsection{Понятие и принцип работы \acs{DI}}

ASP.NET Core поддерживает Dependency Injection, который представляет собой метод достижения инверсии управления 
между классами и их зависимостями. Зависимость -- объект, от которого зависит другой объект.

Dependency Injection -- процесс, в котором внедряется зависимый объект класса в класс, который зависит от этого объекта.
А также, позволяет разрабатывать слабосвязанный код. 

Это делается для того, чтобы класс не зависел от конкретной реализации своей зависимости, 
а лишь от интерфейса или абстракции. Зависимости передаются объекту через конструктор, свойство или метод, а не создаются внутри объекта. 
Вместо того чтобы создавать зависимости внутри класса, \acs{DI} позволяет передать, то есть внедрить эти зависимости извне.\cite{dependency_injection}

\subsection{Виды внедрения зависимостей}

Существуют 3 вида внедрения зависимостей. Данные виды отличаются между собой тем, как именно они передаются объекту.

Первый вид, внедрение через \textbf{конструктор}, где зависимости явно передаются в качестве параметров конструктору клиентского класса во время создания объекта.

Второй вид, внедрение через \textbf{свойство}, где методы сеттера отвечают за установку и изменение значения приватной переменной экземпляра.

Третий вид, внедрение через \textbf{метод}, где зависимость передается в класс через параметры метода.

\subsection{Жизненный цикл зависимостей и их различия}

Жизненный цикл зависимостей -- как долго объект существует в рамках приложения. 

Существуют 3 вида жизненных циклов зависимостей:
\begin{itemize}
    \item
        \textbf{Transient}: при каждом обращении к сервису создается новый объект сервиса, это означает, что каждый раз, 
        когда приложение или класс требует зависимость, контейнер создает новый экземпляр объекта.
    \item
        \textbf{Scoped}: объекты создаются один раз на каждый запрос в приложении, это предполагает, 
        что сохраняется состояние объекта в течение одного запроса, но не на всю жизнь приложения.
    \item
        \textbf{Singleton}:  объекты создаются один раз на всю жизнь приложения, это означает, 
        что создается один экземпляр класса и он используется для всех запросов в процессе работы приложения. 
\end{itemize}

\chapterConclusionSection{intro_chapter_title}

В данной главе были описаны основные понятия и принципы, которые лежат в основе разработки веб-\acs{API} в ASP.NET Core. 
В рамках фреймворка ASP.NET Core можно использовать два подхода для создания веб-\acs{API}: \acs{API} на основе контроллеров и минимальные \acs{API}, 
каждый из которых применим в зависимости от размера и сложности проекта.

Также, были описаны неотъемлемые элементы веб-\acs{API} проектов, такие как архитектурный стиль \acs{REST}, \acs{ORM} фреймворк Entity Framework Core, 
механизм Dependency Injection.

Владение этими знаниями позволяет создать основу для проектирования и программирования веб-\acs{API} приложения.

\chapter{Проектирование архитектуры системы}\label{architecture_chapter_title}

\section{Архитектурное проектирование системы}

\subsection{Монолитная и микросервисная архитектуры}

В разработке веб-приложений существует два основных подхода к построению архитектуры:
\begin{enumerate}
    \item
        \textbf{Монолитная архитектура} -- архитектура, при которой вся система разрабатывается как единое приложение, 
        а также, расширение и обновление системы требуют изменение всей системы.
    \item
        \textbf{Микросервисная архитектура} -- архитектура, при которой система разбивается на отдельные сервисы, 
        каждый из которого отвечает за свою часть функционала, при этом изменения в отдельных частях приложения не влияют на весь проект.\cite{application_architecture}
\end{enumerate}

Так как в ходе разработки проекта получится небольшое веб-приложение, то монолитная архитектура является более подходящей.

\subsection{Modular Monolith}

Modular Monolith -- монолитное приложение, разделённое на логические модули, каждое из которых инкапсулирует свою область ответственности.
Это архитектурный подход, сочетающий в себе аспекты как монолитной, так и модульной парадигм проектирования.\cite{modular_monolith}

\textbf{Характеристики модульного монолита:}
\begin{itemize}
    \item
        Модульность: независимые части приложения с собственными границами ответственности.
    \item 
        Общая кодовая база и данные: единые библиотеки, схемы баз данных и миграции упрощают разработку.
    \item
        Модульные монолиты обеспечивают преимущества масштабируемости и удобства обслуживания по сравнению 
        с традиционными монолитными архитектурами. Разбивая приложение на модули дает возможность более 
        эффективно управлять сложностью и масштабировать отдельные компоненты независимо.
\end{itemize}

\textbf{Основные принципы проектирования Modular Monolith:}
\begin{itemize}
    \item
        Вертикальное разделение -- каждая фича имеет свой модуль: контроллеры, сервисы, репозитории, схемы миграций.
    \item
        Чёткие контракты -- модуль общается только через интерфейсы и DTO.
    \item
        Dependency Inversion -- зависимости направлены внутрь: высокоуровневые модули не зависят от низкоуровневых реализаций.
    \item
        Принцип единой ответственности: каждый модуль имеет лишь одну зону изменений.
\end{itemize}

\subsection{Разделение системы на уровни}

Многоуровневая система -- паттерн проектирования, который разбивает приложение на отдельные уровни, каждый из которых отвечает 
за свою функциональность. Каждый уровень многоуровневой системы не должен быть тесно связан с другими слоями системы. Каждый слой 
выполняет только свою роль и взаимодействует с другими слоями через четко определенные интерфейсы.

Обычно данные уровни включают в себя 4 уровня: уровень представления, уровень бизнес-логики, уровень доступа к данным и 
уровень сущностей:
\begin{enumerate}
    \item
        \textbf{Уровень представления (Presentation Layer)} -- уровень взаимодействия пользователя с приложением, 
        который не должен содержать бизнес-логику и должен быть независимым от логики обработки данных, 
        чтобы можно было легко изменять интерфейс, не затрагивая другие части системы.
    \item
        \textbf{Уровень бизнес-логики (Business Logic Layer)} -- уровень наборов правил и операций, которые определяют,
        как данные обрабатываются внутри системы.
    \item
        \textbf{Уровень доступа к данным (Data Access Layer)} -- уровень взаимодействия с базой данной, 
        в котором хранятся запросы к базе, а также логика сохранения и извлечения данных.
    \item
        \textbf{Уровень сущностей (Entity Layer)} -- уровень опредяющий основные сущности, которые отражают концепии реального 
        мира, эти сущности обычно соответствуют таблицам базы данных, но они не должны содержать бизнес-логику.
\end{enumerate}

\textbf{Преимущества многоуровневой архитектуры:}
\begin{itemize}
    \item
        \textbf{Масштабируемость:} Каждое изменение в одном слое минимально затрагивает другие слои системы.
    \item
        \textbf{Тестируемость:} Каждый слой можно тестировать отдельно, что упрощает написание юнит-тестов и поддержку системы.
    \item
        \textbf{Гибкость:} Многоуровневая архитектура позволяет легко адаптировать систему под изменения, такие как добавление новых функций или улучшение производительности системы.
\end{itemize}

\textbf{Недостатки многоуровневой архитектуры:}
\begin{itemize}
    \item
        При необходимости добавлении новго функционала, нужно изменять каждый слой системы.
    \item
        Не всегда понятно в какой именно слой нужно добавить новые функции или внести изменения.
    \item
        Наличие большого количества избыточных абстракций, не выполняющих функционально значимых операций, 
        но требующих постоянного преобразования объектов и ответов при взаимодействии между уровнями системы.\cite{design_patterns_architecture}
\end{itemize}
 

\section{Подходы к проектированию базы данных}

\subsection{Code-First и Database-First}

В C\# с использованием Entity Framework Core существует два основных подхода к работе с базами данных:
\begin{itemize}
    \item
        \textbf{Code-First} -- сначала создается код, то есть модели, а затем на его основе формируется база данных.

        \textbf{Преимущества Code-First:}
        \begin{enumerate}
                    \item
                        Полный контроль над архитектурой и логикой модели данных.
                    \item
                        Удобно для новых проектов, где структура база данных ещё не определена.
                    \item
                        Лёгкое управление изменениями с помощью миграций.
        \end{enumerate}
    \item
        \textbf{Database-First} -- сначала создается база данных, затем на ее основе автоматически генерируются модели.

        \textbf{Преимущества Database-First:}
        \begin{enumerate}
                    \item
                        Удобен при работе с уже существующими базами данных.
                    \item
                        Быстрая генерация моделей из готовой схемы.
                    \item
                        Поддержка больших legacy-баз.
        \end{enumerate}
\end{itemize}

\subsection{Обоснование выбора подхода для текущего проекта}

Для данной работы был выбран подход Code-First, так как база данных создается с нуля, все изменения можно контролировать через код и миграции,
а также, связи между сущностями создаются автоматически.

\section{Проектирование структуры базы данных}

\subsection{Разработка ER-диаграммы базы данных}

\imageWithCaption{er-diagram}{ER-диаграмма}

\subsection{Описание ключевых сущностей и их атрибутов}

В рамках проектирования базы данных были определены основные сущности, необходимые для функционирования веб-приложения магазина такие как: товар и заказ.

Сущность Product представляет собой товар, доступный в магазине. Он содержит основную информацию, необходимую для отображения и управления товаром в системе.

\textbf{Атрибуты сущности Товар:}
\begin{enumerate}
    \item
        Id (int) -- уникальный идентификатор товара.
    \item
        Name (string) -- название модели товара.
    \item
        Brand (string) -- название производителя товара.
    \item
        Price (decimal) -- цена товара.
\end{enumerate}

\begin{minted}{csharp}
    public class Product
    {
        public int Id { get; set; } 
        public string? Name { get; set; }
        public string? Brand { get; set; }  
    
        [Column(TypeName = "decimal(18,2)")]  
        public decimal Price { get; set; }  
    }
\end{minted}

Сущность Order представляет собой заказ, который содержит информацию о списке товаров.

\textbf{Атрибуты сущности Заказ:}
\begin{enumerate}
    \item
        Id (int) -- уникальный идентификатор заказа.
    \item
        DateTime (DateTime) -- время создания заказа.
    \item
        Status (OrderStatus) -- состояние, в котором находится товар.
    \item
        Items (List<OrderItem>) -- id и количество товара.
    \item
        TotalPrice (decimal) -- общая стоимость товаров.
    \item
        PaymentMethod (PaymentMethod) -- метод оплаты товаров.
\end{enumerate}

\begin{minted}{csharp}
    public class Order
{
    public int Id { get; set; }
    public DateTime DateTime { get; set; }
    public OrderStatus Status { get; set; }
    public List<OrderItem> Items { get; set; } = new List<OrderItem>();
    public decimal TotalPrice { get; set; }
    public PaymentMethod PaymentMethod { get; set; }
}
\end{minted}

\begin{minted}{csharp}
    public class OrderItem
{
    public int Id { get; set; }
    public int ProductId { get; set; }
    public int Quantity { get; set; }
    public Order Order { get; set; } = null!;
    public Product Product { get; set; } = null!;
}
\end{minted}

\section{Ключи в базах данных}

Ключи -- способ идентификации строк в таблице.

Ключи обеспечивают однозначную идентификацию записей и поддерживают целостность данных. 
Без них база превратилась бы в беспорядок, и поиск, обновление или удаление нужной 
информации стало бы практически невозможным.

В СУБД существуют 8 различных типов ключей: супер ключ, первичный ключ, ключ-кандидат
альтернативный ключ, внешний ключ, составной ключ, композитный ключ и суррогатный ключ.

\subsection{Типы ключей}

\textbf{Супер ключ} -- набор одного или нескольких столбцов таблицы, значения которых в совокупности однозначно идентифицируют каждую запись.

\textbf{Ключ-кандидат} -- минимальный, а именно, незаменимый суперключ, то есть суперключ, из которого нельзя убрать ни одного столбца без потери свойства уникальности.

\textbf{Первичный ключ} -- выбранный из кандидатных ключей главный ключ таблицы, на который по умолчанию опираются ссылки и индексы.

\textbf{Альтернативный ключ} -- любой кандидатный ключ, который не был выбран в качестве первичного.

\textbf{Составной ключ} -- ключ, который состоит из двух и более столбцов, значение комбинации которых уникально.

\textbf{Внешний ключ} -- атрибут или набор атрибутов в одной таблице, ссылающиеся на первичный (или кандидантный) ключ другой таблицы.

\textbf{Суррогатный ключ} -- искусственный ключ, предназначенный для уникальной идентификации каждой записи.

\textbf{Композитный ключ} -- комбинация двух или более столбцов, которые однозначно идентифицируют строки в таблице.

\textbf{Необходимость разных типов ключей}
\begin{itemize}
    \item
        Ключи помогают идентифицировать любую строку данных в таблице. 
    \item
        Позволяют установить и определить связь между таблицами.
    \item
        Помогают обеспечить идентичность и целостность в отношениях.
\end{itemize}

\section{Связи между сущностями}

\subsection{Введение}

Связь между таблицами строится с помощью внешних ключей -- это столбец или несколько столбцов в одной таблице, 
где хранятся значения первичного ключа другой таблицы. Так база данных понимает, какие записи связаны между собой, 
и не позволяет нарушить эту связь.

\textbf{Типы связей}
\begin{enumerate}
    \item
        Многие ко многим.
    \item
        Один к многим.
    \item
        Один к одному.
\end{enumerate}

\subsection{Многие ко многим}

В модели "многие ко многим" каждая запись таблицы A может быть связана сразу с несколькими записями таблицы B, 
и одновременно любая запись таблицы B может иметь ссылки на множество записей таблицы A.

\subsection{Один ко многим}

В типе связей "один ко многим" несколько строк из дочерний таблицы зависят от одной строки в родительской таблице.
Данный тип связи поддерживается через внешние ключи в дочерней таблице, значение которых должно либо совпадать 
с существующим первичным ключом родителя, либо быть NULL.

\subsection{Один к одному}

В данном типе связей объекту одной сущности можно сопоставить только один объект другой сущности.
Этот тип связей предполагает разбиение одной большой таблицы на несколько маленьких. 
Основная родительская таблица в этом случае продолжает содержать часто используемые данные, 
а дочерняя зависимая таблица обычно хранит данные, которые используются реже.

\subsection{Настройка связей между сущностями в классе ShopContext}

Для корректной работы с базой данных была настроена связь "один ко многим" между сущностями Product и Order 
в контексте базы данных ShopContext. Один продукт может быть включён в множество заказов.

\section{Бизнес-логика приложения}

\subsection{Введение}

Бизнес-логика представляет собой совокупность правил и условий, управляющих поведением объектов, сущностей, классов и данных внутри приложения.

Приложение служит платформой простого магазина, позволяя:
\begin{itemize}
    \item
        Вести каталог товаров.
    \item
        Оформлять заказы, учитывать их состояние и способы оплаты.
    \item
        Гарантировать целостность данных и корректность расчётов.
\end{itemize}

\subsection{Управление каталогом  товаров}

\begin{itemize}
    \item
        Добавление -- при POST-запросе создаётся запись Product.
    \item 
        Просмотр -- GET-запросы возвращают список или единичный товар.
    \item   
        Редактирование -- PUT изменяет только значимые атрибуты (Name, Brand, Price).
    \item
        Удаление -- DELETE убирает товар из каталога, если на него нет активных заказов.
\end{itemize}

\chapterConclusionSection{architecture_chapter_title}

В данной главе была заложена теоретическая основа архитектуры системы, которую следует реализовать. 
Была определена структура приложения как модульного монолита с чётким разделением на уровни: 
Presentation, Business Logic, Data Access и Entity, что обеспечивает масштабируемость и тестируемость системы.
Этот теоретический фундамент создаёт основу для практической реализации, оставаясь при этом гибким: 
детали внутренней логики валидации, обработки заказов и интеграций будут дорабатываться на последующих этапах.

\chapter{Реализация системы}\label{implementation_chapter_title}

\section{Введение}

Следует реализация архитектуры системы приложения, которое представляет собой простой магазин с основными операциями. 
При разработке системы внимание уделялось разделению ответственности между компонентами системы.

Первый уровень представляет собой слой приёма и обработки \acs{HTTP}-запросов -- контроллеры ASP.NET Core, 
отвечающие за валидацию входных данных и преобразование их в \acs{DTO}-объекты. 
За ними следует слой сервисов, где реализована бизнес-логика: управление товарами, расчёт итоговой стоимости 
и обработка заказов согласно заданным правилам.

Нижний уровень -- слой доступа к данным (Data Access Layer), построенный с использованием \acs{EF} Core. 
Здесь происходит взаимодействие с базой данных: создание миграций, выполнение \acs{CRUD}-операций и 
обеспечение целостности хранящихся сущностей (Product, Order).

Документирование \acs{API} осуществляется с помощью Swagger, что позволяет автоматически генерировать описание доступных эндпоинтов.

\section{\acs{DTO}}

\textbf{\acs{DTO}} -- простой контейнер для данных. Он не содержит никакой бизнес-логики или поведения.
Его единственная задача -- передавать данные между слоями приложения.

\textbf{Преимущества \acs{DTO}:}
\begin{itemize}
    \item
        Инкапсуляция: \acs{DTO} предотвращает сущности базы данных быть видимыми клиенту.
    \item
        Decoupling: сохраняет сущности и контроллеры независимыми, что позволяет легче изменять
        код, не нарушая зависимости.
    \item
        Версионирование: \acs{DTO} облегчают версионирование \acs{API} без того, чтобы повлиять на сущности.
    \item
        Валидация входящих данных: в \acs{DTO} классы можно добавлять атрибуты, которые автоматически убирают 
        некорректные данные.\cite{dto}
\end{itemize}

\textbf{\acs{DTO} для Товаров в приложении:}

\begin{minted}{csharp}
    public class ProductDto
    {
        public int Id { get; set; } 
        public string? Name { get; set; }
        public string? Brand { get; set; }
        public decimal Price { get; set; }
    }
\end{minted}

\textbf{\acs{DTO} для OrderItem:}

\begin{minted}{csharp}
    public class OrderItemDto
    {
        public int ProductId { get; set; }
        public int Quantity { get; set; }
    }
\end{minted}

\textbf{\acs{DTO} для Заказов:}

\begin{minted}{csharp}
    public class OrderDto
    {
        public int Id { get; set; }
        public DateTime DateTime { get; set; }
        public OrderStatus Status { get; set; }
        public PaymentMethod PaymentMethod { get; set; }
        public decimal TotalPrice { get; set; }
        public List<OrderItemDto> Items { get; set; } = new();
    }
\end{minted}

\section{Валидация данных}

Валидация данных, которые передаются в \acs{API} -- процесс проверки того, что клиент прислал корректную, полную и безопасную информацию для дальнейшей ее обработки. 
Валидация данных предотвращает случаи, когда приложение рушится из-за неожиданных и некорректных данных, передаваемых в \acs{API}, то есть бизнес-логика принимает 
только прошедшие проверку данные.

\textbf{Валидация данных в классе CreateProductDto}
\begin{minted}{csharp}
    public class CreateProductDto
    {
        [Required]
        [StringLength(100, MinimumLength = 4)]
        public string Name { get; set; } = null!;
        [Required]
        [StringLength(100)]
        public string Brand { get; set; } = null!;
        [Range(0.01, double.MaxValue, ErrorMessage = "Price must be positive.")]
        public decimal Price { get; set; }
    }
\end{minted}

\textbf{Валидация данных в классе CreateOrderItemDto}
\begin{minted}{csharp}
    public class CreateOrderItemDto
    {
        [Required]
        [Range(1, int.MaxValue, ErrorMessage = "Id must be greater than zero.")]
        public int ProductId { get; set; }
        [Required]
        [Range(1, int.MaxValue, ErrorMessage = "Quantity must be at least 1.")]
        public int Quantity { get; set; }
    }
\end{minted}

\textbf{Валидация данных в классе CreateOrderDto}
\begin{minted}{csharp}
    public class CreateOrderDto
    {
        [Required]
        public DateTime DateTime { get; set; }
        [Required]
        public OrderStatus Status { get; set; }
        [Required]
        public PaymentMethod PaymentMethod { get; set; }
        [Required]
        [MinLength(1, ErrorMessage = "At least one order item is required.")]
        public List<CreateOrderItemDto> Items { get; set; } = new();
    }
\end{minted}

\textbf{Валидация данных в классе UpdateProductDto}
\begin{minted}{csharp}
    public class UpdateProductDto
    {
        [Required]
        [StringLength(100, MinimumLength = 4)]
        public string Name { get; set; } = null!;

        [Required]
        [StringLength(100)]
        public string Brand { get; set; } = null!;
        [Range(0.01, double.MaxValue, ErrorMessage = "Price must be positive.")]
        public decimal Price { get; set; }
}
\end{minted}

\textbf{Валидация данных в классе UpdateOrderDto}
\begin{minted}{csharp}
    public class UpdateOrderDto
    {
        [Required]
        public OrderStatus Status { get; set; }
        [Required]
        public PaymentMethod PaymentMethod { get; set; }
    }
\end{minted}

\section{Контроллеры}

Контроллер -- точка входа HTTP-запросов в \acs{API}. Он отвечает за приём \acs{HTTP}-запросов и формирование \acs{HTTP}-ответов, 
действует как мост между \acs{HTTP} и сущностями базы данных, а также, следует принципу единой ответственности, то есть реализует 
только \acs{CRUD}-операции. Вся бизнес-логика и сложные проверки выносится в сервисный слой, а контроллеры лишь вызывают нужные 
методы и возвращают результат клиенту.

У каждого контроллера есть декорации, которые определяют, что данный класс будет именно контроллером, 
а также, класс, от которого наследует контроллер:
\begin{minted}{csharp}
    [Route("api/[controller]")]
    [ApiController]
    public class ProductController : ControllerBase
\end{minted}

Внедряются зависимости, где \texttt{ShopContext} класс дает доступ к базе данных через \acs{EF} Core, а \texttt{IMapper} (из \texttt{AutoMapper}) 
нужен для преобразования между \acs{DTO} и сущностями.
\begin{minted}{csharp}
    private readonly ShopContext _shopContext;
    private readonly IMapper _mapper;
    
    public ProductController(ShopContext shopContext, IMapper mapper)
    {
        _shopContext = shopContext;
        _mapper = mapper;
    }    
\end{minted}

Каждый метод привязан к \acs{HTTP}-глаголу и маршруту:
\begin{itemize}
    \item Создание:
\end{itemize}

\begin{minted}{csharp}
    [HttpPost]
    public async Task<ActionResult<ProductDto>> AddProduct([FromBody] CreateProductDto createDto)

    [HttpPost]
    public async Task<ActionResult<OrderDto>> CreateOrder([FromBody] CreateOrderDto createDto)
\end{minted}

\begin{itemize}
    \item Чтение списка:
\end{itemize}

\begin{minted}{csharp}
    [HttpGet]
    public async Task<ActionResult<IEnumerable<ProductDto>>> GetProducts()

    [HttpGet]
    public async Task<ActionResult<IEnumerable<OrderDto>>> GetOrders()
\end{minted}

\begin{itemize}
    \item Чтение по id:
\end{itemize}

\begin{minted}{csharp}
    [HttpGet("{id}")]
    public async Task<ActionResult<ProductDto>> GetProduct(int id)

    [HttpGet("{id}")]
    public async Task<ActionResult<OrderDto>> GetOrder(int id) 
\end{minted}

\begin{itemize}
    \item Обновление:
\end{itemize}

\begin{minted}{csharp}
    [HttpPut("{id}")]
    public async Task<ActionResult<ProductDto>> UpdateProduct(int id, [FromBody] UpdateProductDto updateDto)
    
    [HttpPut("{id}")]
    public async Task<ActionResult<OrderDto>> UpdateOrder(int id, [FromBody] UpdateOrderDto updateDto)
\end{minted}

\begin{itemize}
    \item Удаление:
\end{itemize}
    
\begin{minted}{csharp}
    [HttpDelete("{id}")]
    public async Task<IActionResult> DeleteProduct(int id)

    [HttpDelete("{id}")]
    public async Task<IActionResult> DeleteOrder(int id)
\end{minted}

\subsection{\acs{CRUD}-операции}

\acs{CRUD} -- базовые операции для работы с данными в веб-\acs{API} приложении.

\textbf{Создание:}

Класс \texttt{ProductController}:
\begin{minted}{csharp}
    var product = _mapper.Map<Product>(createDto);
    _shopContext.Products.Add(product);
    await _shopContext.SaveChangesAsync();

    var productDto = _mapper.Map<ProductDto>(product);
    return CreatedAtAction(nameof(GetProduct), new { id = product.Id }, productDto);
\end{minted}

Класс \texttt{OrderController}:
\begin{minted}{csharp}
    var productIds = createDto.Items.Select(i => i.ProductId).ToList();
    var products = await _context.Products
        .Where(p => productIds.Contains(p.Id))
        .ToListAsync();

        
    var order = _mapper.Map<Order>(createDto);

    order.TotalPrice = createDto.Items.Sum(i =>
    {
        var prod = products.First(p => p.Id == i.ProductId);
        return prod.Price * i.Quantity;
    });

    _context.Orders.Add(order);
    await _context.SaveChangesAsync();

    var orderDto = _mapper.Map<OrderDto>(order);
    return CreatedAtAction(nameof(GetOrder), new { id = order.Id }, orderDto);
\end{minted}

\textbf{Чтение списка:}

Класс \texttt{ProductController}:
\begin{minted}{csharp}
    var products = await _shopContext.Products.ToListAsync();
    return Ok(_mapper.Map<IEnumerable<ProductDto>>(products));
\end{minted}

Класс \texttt{OrderController}:
\begin{minted}{csharp}
    var orders = await _context.Orders
        .Include(o => o.Items)
        .ToListAsync();

    return Ok(_mapper.Map<IEnumerable<OrderDto>>(orders));
\end{minted}

\textbf{Чтение по id:}

Класс \texttt{ProductController}:
\begin{minted}{csharp}
    var product = await _shopContext.Products.FindAsync(id);
        if (product == null)
            return NotFound();

    return _mapper.Map<ProductDto>(product);
\end{minted}

Класс \texttt{OrderController}:
\begin{minted}{csharp}
    var order = await _context.Orders
        .Include(o => o.Items)
        .FirstOrDefaultAsync(o => o.Id == id);

    if (order == null)
        return NotFound();

    eturn _mapper.Map<OrderDto>(order);
\end{minted}

\textbf{Обновление:}

Класс \texttt{ProductController}:
\begin{minted}{csharp}
    var product = await _shopContext.Products.FindAsync(id);
    if (product == null)
        return NotFound();

    _mapper.Map(updateDto, product);
    await _shopContext.SaveChangesAsync();

    return Ok(_mapper.Map<ProductDto>(product));
\end{minted}

Класс \texttt{OrderController}:
\begin{minted}{csharp}
    var order = await _context.Orders.FindAsync(id);
    if (order == null)
        return NotFound();

    _mapper.Map(updateDto, order);
    await _context.SaveChangesAsync();

    return Ok(_mapper.Map<OrderDto>(order));
\end{minted}

\textbf{Удаление:}

Класс \texttt{ProductController}:
\begin{minted}{csharp}
    var product = await _shopContext.Products.FindAsync(id);
    if (product == null)
        return NotFound("Product not found.");

    _shopContext.Products.Remove(product);
    await _shopContext.SaveChangesAsync();

    return NoContent();
\end{minted}

Класс \texttt{OrderController}:
\begin{minted}{csharp}
    var order = await _context.Orders.FindAsync(id);
    if (order == null)
        return NotFound();

    _context.Orders.Remove(order);
    await _context.SaveChangesAsync();

    return NoContent();
\end{minted}

\section{Создание базы данных}

База данных -- одна из главных частей веб-\acs{API} приложения, 
обеспечивающее долговременное хранение и целостность бизнес-данных.

\textbf{Характеристики базы данных:}
\begin{itemize}
    \item
        Организованное хранение данных: данные хранятся в структурированных 
        форматах, таких как таблицы, документы или пары ключ-значение.
    \item
        Эффективный доступ: расширенные возможности поиска и запросов позволяют быстро извлекать данные.
    \item
        Безопасность и масштабируемость: базы данных обеспечивают надежные меры 
        безопасности и могут масштабироваться по мере роста потребностей в данных.\cite{database}
\end{itemize}

\textbf{Для создания базы данных в SQL Server нужно выполнить следующие шаги:}
\begin{enumerate}
    \item
        Подключение к серверу: в SQL Server Management Studio в окне "Connect to Server" 
        указывается имя инстанса, способ аутентификации и нажимается "Connect".
    \item
        Создание базы данных: в Object Explorer в Databases выбирается New Database 
        и вводится имя базы данных.
\end{enumerate}

\textbf{Для того, чтобы приложение было связно с базой данных требуется настроить 
строку подключения в классах \texttt{Program} и \texttt{appsettings.json}:}

В классе \texttt{Program}:
\begin{minted}{csharp}
    var builder = WebApplication.CreateBuilder(args);
    var connectionString = builder.Configuration.GetConnectionString("ShopContext") ??
        throw new InvalidOperationException("Connection string 'ShopContext' not found");
    builder.Services.AddDbContext<ShopContext>(options =>
        options.UseSqlServer(connectionString));
\end{minted}

В классе \texttt{appsettings.json}:
\begin{minted}{csharp}
  "ConnectionStrings": {
    "ShopContext": "Server=DESKTOP\\SQLEXPRESS;Database=ShopDB;Trusted_Connection=True;TrustServerCertificate=True;"
}
\end{minted}
    
\section{Миграции}

Миграции позволяют постепенно обновлять схему базы данных, чтобы поддерживать ее синхронизацию 
с моделью данных приложения, сохраняя при этом существующие данные в базе данных.\cite{migration}

\textbf{Миграции позволяют:}
\begin{itemize}
    \item
        Отслеживать изменения в моделях (в классе \texttt{ShopContext} и сущностях).
    \item
        Автоматически генерировать \acs{SQL}-код для обновления схемы базы данных под данные изменения.
    \item
        Управлять историей изменений через файлы миграций с методами \texttt{Up()} (применить) и \texttt{Down()} (откатить).
    \item
        Восстанавливать базу данных до любого сохраненного состояния.
\end{itemize}

\textbf{Для создания и применения новой миграции требуется выполнить следующие консольные команды:}
\begin{enumerate}
    \item
        Создание:

        \texttt{dotnet ef migrations add <MigrationName>}
    \item
        Применение:

        \texttt{dotnet ef database update}
\end{enumerate}

\section{Unit-тестирование}

Unit-тесты проверяют отдельные части приложения независимо от его инфраструктуры и внешних зависимостей. 
При этом тестируется только логика конкретного действия контроллера, без учёта работы его зависимостей.
Unit-тесты проверяют только логику внутри метода, не задействуя базу данных. Каждый тест должен выполняться 
за миллисекунды и не зависеть от порядка. Следует создавать тесты простыми и фокусированными на одной проверке, 
а также, называть методы по схеме: Метод\_Сценарий\_ОжидаемыйРезультат.

У каждого unit-теста есть декорации, которые определяют, что данный класс и методы будут частью unit-теста: 
\texttt{[TestClass]} и \texttt{[TestMethod]}.

\subsection{Шаблон AAA (Arrange-Act-Assert)}
\begin{itemize}
    \item
        Arrange -- подготовка входных данных.
    \item
        Act -- вызов тестируемого метода.
    \item
        Assert -- проверка результата, то есть возвращаемого значения, статуса ответа или исключения.
\end{itemize}

\subsection{Заглушки в unit-тестах}
Заглушка -- тестовый объект, который возвращает заранее определённые данные, 
но сам по себе не содержит логики. При unit-тестировании заглушки подставляют вместо реальных зависимостей, 
чтобы закрепить поведение метода в контроллере и фокусироваться только на логике.

\textbf{Преимущества заглушек:}
\begin{enumerate}
    \item
        Заглушки избавляют от необходимости держать тестируемый код привязанным к базе данных.
    \item
        Всегда возвращают предсказуемый результат, упрощая проверку "Arrange-Act-Assert".
    \item
        Тесты с заглушками выполняются мгновенно, без реальных запросов.
\end{enumerate}

\subsection{Moq}

Moq - библиотека для создания мок-объектов. Она позволяет подменять реализации зависимостей на управляемые объекты, 
настраивать их поведение и проверять, как тестируемый код с ними взаимодействует. Следует использовать moq для внешних зависимостей, 
а не для самой логики, которая тестируется. Если использовать \texttt{Setup().Returns()} и не вызывать \texttt{Verify()}, 
то мок ведет себя как заглушка, но если добавить \texttt{Verify()}, то можно использовать все возможности mock-объекта. 

    
\unnumberedChapter{Окончательные выводы и рекомендации}

В данной работе была обсуждена важность изучения веб-\acs{API} для создания современных приложений. 
В ходе изучения веб-\acs{API} ASP.NET Core стало ясно, что данная технология является не только стандартом 
в написании веб-\acs{API} приложений, но и еще одной из самых универсальных экосистем разработки, которая 
предоставляет полный набор встроенных инструментов для создания веб-\acs{API} приложений. Также, был обсужден 
процесс разработки приложения простого магазина, который выполняет \acs{CRUD}-операции.

Выполнение данной работы стало для автора ценным практическим опытом, существенно углубившим понимание 
архитектуры веб-\acs{API} и особенностей разработки на платформе ASP.NET Core. 
Благодаря самостоятельному решению задач проектирования, настройки миграций и тестирования, 
автор приобрел уверенные навыки работы с \acs{EF} Core, внедрением валидации и асинхронных контроллеров. 
Этот опыт послужил прочным фундаментом для дальнейшего профессионального роста, расширил технический 
кругозор и укрепил готовность к реализации более сложных и масштабных проектов в будущем, а также, 
реализации проекта, который упоминался в мотивации создания приложения.


Текст данной работы можно получить на GitHub по следующей ссылке: \githubthesis, 
а весь исходный код, можно получить на GitHub по следующей ссылке: \githubwebAPI.

%Rezultatele obținute au fost raportate la \textbf{\conferencesList}\cite{self}.

\newpage
\markpage{usefulStuffEnd}


% Bibliography
\bibliographystyle{plain}
\bibliography{bibliography}
\addcontentsline{toc}{chapter}{\bibname}

% Appendices
% \appendix

% \unnumberedChapter{Anexe}

% \section{Funcția actualizării valorii CRC}\label{appendix:crc} %407


% \section{Iteratorul segmentelor unei secvențe}\label{appendix:sequence_iterator} %1044


% \section{Calculul CRC în parser}\label{appendix:crc_sequence_defer_example} %1077



% \section{TaggedArrayList.zig}\label{appendix:main__TaggedArrayList} %1678

% \section{Codul cheie arborelui Huffman}\label{appendix:huffman_tree}%1792



% \section{Afișarea editorului hex}\label{appendix:draw_hex_grid}%2062


% \section{Căutarea drumului de noduri în arbore}\label{appendix:node_path_search_impl}%2086


% \section{Drag-and-drop}\label{appendix:drag_and_drop}%2106


% \section{common.zig}\label{appendix:main__parser_png_common}
% \inputminted{zig}{../src/parser/png/common.zig}

% \section{chunks.zig}\label{appendix:main__parser_png_chunks}
% \inputminted{zig}{../src/parser/png/chunks.zig}

% \section{parser.zig}\label{appendix:main__parser_png_parser}
% \inputminted{zig}{../src/parser/png/parser.zig}

% \section{utils.zig}\label{appendix:main__parser_png_utils}
% \inputminted{zig}{../src/parser/png/utils.zig}

% \section{zlib.zig}\label{appendix:main__parser_zlib_zlib}
% \inputminted{zig}{../src/parser/zlib/zlib.zig}

% \section{helper.zig}\label{appendix:main__parser_zlib_helper}
% \inputminted{zig}{../src/parser/zlib/helper.zig}

% \section{deflate.zig}\label{appendix:main__parser_zlib_deflate}
% \inputminted{zig}{../src/parser/zlib/deflate.zig}

% \section{huffmanTree.zig}\label{appendix:main__parser_zlib_huffmanTree}
% \inputminted{zig}{../src/parser/zlib/huffmanTree.zig}

% \section{noCompression.zig}\label{appendix:main__parser_zlib_noCompression}
% \inputminted{zig}{../src/parser/zlib/noCompression.zig}

% \section{dynamic.zig}\label{appendix:main__parser_zlib_dynamic}
% \inputminted{zig}{../src/parser/zlib/dynamic.zig}

% \section{fixed.zig}\label{appendix:main__parser_zlib_fixed}
% \inputminted{zig}{../src/parser/zlib/fixed.zig}

% \section{ast.zig}\label{appendix:main__parser_shared_ast}
% \inputminted{zig}{../src/parser/shared/ast.zig}

% \section{Settings.zig}\label{appendix:main__parser_shared_Settings}
% \inputminted{zig}{../src/parser/shared/Settings.zig}

% \section{level.zig}\label{appendix:main__parser_shared_level}
% \inputminted{zig}{../src/parser/shared/level.zig}

% \section{NodeOperations.zig}\label{appendix:main__parser_shared_NodeOperations}
% \inputminted{zig}{../src/parser/shared/NodeOperations.zig}

% \section{CommonContext.zig}\label{appendix:main__parser_shared_CommonContext}
% \inputminted{zig}{../src/parser/shared/CommonContext.zig}

% \section{pngDebug.zig}\label{appendix:main__pngDebug}
% \inputminted{zig}{../src/pngDebug.zig}

\end{document}
% vim: fdm=syntax
